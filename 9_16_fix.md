# Bug Fixing Plan: 9/16

## Bug 1: Text-entry evidence submission results in "[object Object]" error

**Description:** When a student submits text-entry evidence for a task completion, it results in an error and displays the string "[object Object]" instead of a meaningful error message.

**Plan:**

1.  **Identify the problematic code:**
    *   Search the frontend codebase (especially in `frontend/src/pages` and `frontend/src/components`) for code related to task completion and evidence submission.
    *   Look for how evidence is submitted, particularly for text-based evidence.
    *   Pinpoint where the "[object Object]" error is being displayed in the UI.

2.  **Analyze the code:**
    *   Examine the error handling logic for the evidence submission process.
    *   It's likely that a JavaScript error object is being directly rendered as a string, causing the "[object Object]" display.
    *   Determine the structure of the error object being returned.

3.  **Fix the code:**
    *   Modify the frontend code to properly handle the error object.
    *   Instead of rendering the entire object, extract and display a user-friendly error message from the object's properties (e.g., `error.message` or a specific message from the API response).

4.  **Test the fix:**
    *   Manually test the text-entry evidence submission process to confirm that the "[object Object]" error is gone.
    *   Verify that a clear and informative error message is displayed if the submission fails.
    *   Ensure that successful submissions are not negatively affected.

**Fix:**

The issue was in `frontend/src/components/quest/TaskCompletionModal.jsx`. The error handling code was not correctly parsing the error message from the API response, which was sometimes an object instead of a string. This caused the React frontend to render the error object as `[object Object]`.

The fix involves updating the error handling logic to check if the error message is a string. If it's not, it stringifies the error object to ensure that a readable message is always displayed.

Specifically, the following code was changed:

```javascript
// Check for HTTP error status
if (!response.ok) {
    const errorMessage = data.error || data.message || 'Failed to complete task';
    throw new Error(errorMessage);
}

// Check for API-level success flag (backend uses success: true/false)
if (data.success === false) {
    throw new Error(data.error || data.message || 'Failed to complete task');
}
```

To this:

```javascript
// Check for HTTP error status
if (!response.ok) {
    const errorDetail = data.error || data.message;
    const errorMessage = typeof errorDetail === 'string' ? errorDetail : JSON.stringify(errorDetail) || 'Failed to complete task';
    throw new Error(errorMessage);
}

// Check for API-level success flag (backend uses success: true/false)
if (data.success === false) {
    const errorDetail = data.error || data.message;
    const errorMessage = typeof errorDetail === 'string' ? errorDetail : JSON.stringify(errorDetail) || 'Failed to complete task';
    throw new Error(errorMessage);
}
```

## Bug 2: "Manage Source Images" in the admin dashboard says "failed to load sources"

**Description:** When an admin clicks on "Manage Source Images" in the admin dashboard, a modal appears but it shows a "failed to load sources" error.

**Analysis:**

1.  The "Manage Source Images" button in `frontend/src/pages/AdminPage.jsx` opens the `SourcesManager` component.
2.  The `SourcesManager` component in `frontend/src/components/SourcesManager.jsx` makes a `GET` request to `/api/v3/admin/quest-sources` to fetch the list of quest sources.
3.  The `catch` block for this API call displays the "Failed to load sources" error message.
4.  The backend file `backend/routes/admin_v3.py` did not have an endpoint to handle `/api/v3/admin/quest-sources` requests.

**Fix:**

A new endpoint has been added to `backend/routes/admin_v3.py` to handle `GET` requests to `/api/v3/admin/quest-sources`. This endpoint fetches all quest sources from the `quest_sources` table in the database, counts the number of quests associated with each source, and returns the data as a JSON response. This provides the necessary data for the `SourcesManager` component and resolves the error.

The following code was added to `backend/routes/admin_v3.py`:

```python
@bp.route('/quest-sources', methods=['GET'])
@require_admin
def get_quest_sources(user_id):
    """Get all quest sources with their usage count."""
    supabase = get_supabase_admin_client()
    try:
        # Get all sources
        sources_response = supabase.table('quest_sources').select('*').execute()
        if not sources_response.data:
            return jsonify({'sources': []})

        sources = sources_response.data
        
        # Get quest counts for each source
        for source in sources:
            count_response = supabase.table('quests').select('id', count='exact').eq('source', source['id']).execute()
            source['quest_count'] = count_response.count if count_response.count else 0

        return jsonify({'sources': sources})
    except Exception as e:
        print(f"Error fetching quest sources: {str(e)}")
        return jsonify({'error': 'Failed to fetch quest sources'}), 500
```

## Bug 3: Tasks are displayed in a random order in the quest

**Description:** The tasks within a quest are displayed in a random order, not in the order they were added in the quest creation form.

**Analysis:**

1.  The frontend component `frontend/src/pages/AdminPage.jsx` is responsible for rendering the quests and their tasks in the admin dashboard.
2.  The code attempts to sort the tasks using `task.task_order`, but the correct field in the database and the API response is `task.order_index`.

**Fix:**

The fix was to update the sorting logic in `frontend/src/pages/AdminPage.jsx` to use the correct field, `order_index`, for sorting the tasks. This ensures that the tasks are displayed in the order they were intended.

The following code was changed:

```javascript
.sort((a, b) => (a.task_order || 0) - (b.task_order || 0))
```

To this:

```javascript
.sort((a, b) => (a.order_index || 0) - (b.order_index || 0))
```
